package org.onjava.operators;

/**
 * 字符串操作符+和+=
 * Java中的字符串操作符有一种特殊用法：正如你所看到的那样，+和+=操作符都可以连接字符串。这种用法感觉十分自然，尽管这并不符合它们的传统使用方式。
 *
 * 对C++来说这个功能看起来还不错，因此它引入了操作符重载（operator overloading），允许C++程序员为几乎所有的操作符添加新含义。
 * 遗憾的是，操作符重载在和C++的一些其他限制结合后，变成了一个相当复杂的特性，使得程序员不容易将它们设计到自己的类中。
 * 尽管Java如果要实现操作符重载的话肯定比C++中的简单许多（就像C#语言所演示的那种简单直接的操作符重载），它仍然被认为过于复杂，所以Java程序员无法像C++和C#程序员那样实现自己的重载操作符。
 *
 * 如果表达式以一个字符串开头，则其后的所有操作数都必须是字符串类型的（编译器会自动把双引号里的字符序列转换成字符串）：
 */
public class StringOperators {
    public static void main(String[] args) {
        int x = 0, y = 1, z = 2;
        String s = "x, y, z ";
        System.out.println(s + x + y + z);
        // 将x转为字符串
        System.out.println(x + " " + s);
        s += "(summed) = "; // 拼接操作符
        System.out.println(s + (x + y + z));
        // Integer.toString()的简化版：
        System.out.println("" + x);
    }
}
/*
注意第一个语句的输出是012，而不是对整数求和得到的3。这是因为Java编译器将x、y和z转换为它们的字符串表示形式，然后进行了拼接，而不是先将它们相加。
第二个打印语句将前面的变量转换为字符串类型，因此字符串转换并不取决于先后顺序。
最后，你会看到+=操作符将一个字符串拼接到变量s后，使用括号来控制表达式执行的顺序，因此表达式先对int类型的变量进行了求和，然后才显示了结果。

注意main()方法里的最后一个示例：你有时会看到一个空的字符串后跟一个+和一个基本类型，这是执行类型转换的一种方式，这样就不用调用更麻烦的显式方法（此处为Integer.toString()）。

使用操作符时常犯的错误
使用操作符时一个常犯的错误是，即使你对表达式的执行方式不确定，也不愿意使用括号。
这个问题在Java中也存在。
C和C++中一个极其常见的错误如下所示：
while(x = y) {
  // ...
}
在这里，程序员显然是想测试是否相等（==）而不是赋值。
在C和C++中，如果y非零，则这里的结果将始终为true，你可能会得到一个无限循环。
在Java中，这个表达式的执行结果不是boolean类型，但编译器需要一个boolean类型。
而且因为Java中无法自动将int类型转为boolean类型，所以编译器会直接显示一个编译时错误，让你在运行程序之前就能发现问题。
因此，这种错误在Java中不会发生。
（唯一不会得到编译时错误的情况是x和y都是boolean类型，此时x = y是一个合法的表达式，而在前面的示例中，这可能是一个错误。）

C和C++中的一个类似问题是，在应该使用逻辑操作符的时候使用了按位“与”和按位“或”操作符。按位“与”和按位“或”使用了一个字符（&或|），而逻辑“与”和逻辑“或”使用了两个字符（&&和||）。
就像=和==一样，在应该输入两个字符的地方输入了一个字符的错误很容易发生。在Java中，编译器防止了这种情况的发生，它不会让你在不适合的地方随意使用某个操作符。
 */